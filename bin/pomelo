#!/usr/bin/env node

/**
 * Module dependencies.
 */

var fs = require('fs')
    , os = require('os')
    , cp = require('child_process')
    , utils = require('../lib/util/utils')
    , ph = require('path')
    , exec = cp.exec
    , spawn = cp.spawn;

/**
 * Package information.
 */

var pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json'));

/**
 * Framework version.
 */

var version = pkg.version;

/**
 * End-of-line code.
 */

var eol = os.platform
    ? ('win32' == os.platform() ? '\r\n' : '\n')
    : '\n';


// list command socket address
var LIST_COMMAND_ADDRESS = 'http://127.0.0.1:9999';

var TIME_KILL_WAIT = 6000;


// Parse arguments

var args = process.argv.slice(2)
    , path = '.';

// Get the name of Project
var name = args[1];
var name_path = name;
if (name_path && name_path.indexOf('/')) {
    var str = name_path.split('/');
    name = str[str.length - 1];
}
var cwd = process.cwd();
if (name === '.') {
    var arr = cwd.split('/');
    name = arr[arr.length - 1];
}

if (name === '..') {
    var arr = cwd.split('/');
    name = arr[arr.length - 2];
}


/**
 * Usage documentation.
 */
var usage = ''
        + '\n'
        + '  Usage: pomelo [action] [path/option]\n'
        + '\n'
        + '  Options:\n'
        + '    init  [path]              init the program\n'
        + '    start [option]            start the program\n'
        + '    stop                      stop the program\n'
        + '    version                   output framework version\n'
        + '    help                      output help information\n'
        + '    [option]                  --debug=serverId:port'
    ;

/**
 * package.json template.
 */

var json = '{' + eol;
json += '   "name" : "' + name + '",' + eol;
json += '   "version" : "0.1.0",' + eol;
json += '   "private" : false,' + eol;
json += '  "dependencies": {' + eol;
json += '   "express" : "2.5.2"' + eol;
json += '    ,"connect" : ">=0.0.1"' + eol;
json += '     ,"log4js" : ">=0.4.1"' + eol;
json += '     , "socket.io" :  ">=0.9.4"' + eol;
json += '     , "generic-pool" :  ">=1.0.9"' + eol;
json += '     , "mysql" :  ">=0.9.5"' + eol;
json += '     , "pomelo" :  ">=0.1.11"' + eol;
json += '     , "socket.io-client" :  ">=0.9.4"' + eol;
json += '     ,"underscore"  : ">=1.3.1"' + eol;
json += '     ,"libxmljs"  :  ">=0.0.1"' + eol;
json += '     ,"async" : ">=0.0.1"' + eol;
json += '      ,"aoi-service" : ">=0.2.0"' + eol;
json += '     ,"crc" : ">=0.0.1"' + eol;
json += ' },' + eol;
json += ' "devDependencies" : {' + eol;
json += '  "flow" : ">=0.2.2"' + eol;
json += '  , "should" : ">=0.0.1"' + eol;
json += '  , "mocha" : ">=0.0.1"' + eol;
json += '} ';
json += '}' + eol;


/**
 * App template.
 */
var app = [
    ''
    , '/**'
    , ' * Module dependencies.'
    , ' */'
    , 'var pomelo = require(\'pomelo\')'
    , ''
    , 'var appTemplate = pomelo.appTemplate;'
    , 'var app = appTemplate.init();'
    , ''
    , '// Configuration'
    , '  app.set(\'name\', \'' + name + '\');'
    , '  app.set(\'dirname\', __dirname);'
    , '  appTemplate.defaultConfig(app);'
    , ''
    , '// Start'
    , 'app.start();'
    , ''
    , 'function startWebServer(){'
    , ' var app_express = require(\'./app_express\');'
    , ' console.log(\'[AppWebServerStart] listen, visit http://0.0.0.0:3001/index.html\');'
    , '}'
    , ''
    , 'if(app.serverType===\'master\'){'
    , ' startWebServer();'
    , '}'
    , ''
].join(eol);


// Parse command
var arg = args.shift();
switch (arg) {
    case 'help':
        legalArgNum(0);
        abort(usage);
        break;
    case 'version':
        legalArgNum(0);
        abort(version);
        break;
    case 'list':
        legalArgNum(0);
        list();
        break;
    case 'init':
        legalArgNum(1);
        path = args[0];
        init();
        break;
    case 'start':
        start();
        break;
    case 'stop':
        legalArgNum(0);
        terminal('stop');
        break;
    case 'kill':
        legalArgNum(0);
        terminal('kill');
        break;
    default:
        abort("The command is error format.");
        break;
}


// Init application
function init() {
    emptyDirectory(path, function (empty) {
        if (empty) {
            createApplicationAt(path);
        } else {
            confirm('destination is not empty, continue? ', function (ok) {
                if (ok) {
                    process.stdin.destroy();
                    createApplicationAt(path);
                } else {
                    abort('aborting');
                }
            });
        }
    });
}

/**
 * Create application at the given directory `path`.
 *
 * @param {String} path
 */
function createApplicationAt(path) {
    // copy(__dirname + '/../template/', path);
    mkdir(path + '/logs', 0);
    write(path + '/app.js', app);
    write(path + '/package.json', json);
}


// start the program
function start() {
    //debug args
    var serverId = " ";
    var port = " ";

    if (args.length != 0)
        if (args[0] != 'production' && args[0] != 'development')
            if (!utils.startWith(args[0], '--debug='))
                abort("The start command  arguments is error.");

    function parseServer(str) {
        if (str.indexOf(':') < 0 || str.indexOf(':') != str.lastIndexOf(':'))
            abort("The debug argument is error.");
        var str = str.substr(8, str.length - 8);
        serverId = str.split(':')[0];
        port = str.split(':')[1];
        var re = /^[1-9]+[0-9]*]*$/;
        if (!re.test(port))
            abort("The debug port is not Number.");
        var lp = Number(port);
        if (lp < 1024 || lp > 65535)
            abort("The debug port is out of range.");
    }

    if (ph.existsSync('./app.js')) {
        if (ph.existsSync(process.cwd() + '/tmp')) {
            var ex = exec('ps -p ' + fs.readFileSync(process.cwd() + '/tmp'), function (error, stdout, stderr) {
                if (stdout.length > 28) {
                    abort("The program is still running,please stop it first.");
                }
            });
        }

        var ls;
        switch (args.length) {
            case 0:
                ls = spawn('node', ['app.js']);
                break;
            case 1:
                if (args[0] === 'development' || args[0] === 'production') {
                    ls = spawn('node', ['app.js', 'env', args[0]]);
                }
                else {
                    parseServer(args[0]);
                    if (legalServerId(args[0], serverId) === false) {
                        abort("The serverId does not exist.");
                    }
                    ls = spawn('node', ['app.js', 'env', 'development', 'serverType', 'master', 'serverId'  , 'master-server-1', 'debugServerId', serverId, 'debugPort', port]);
                }
                break;
            case 2:
                parseServer(args[1]);
                if (legalServerId(args[0], serverId) === false) {
                    abort("The serverId does not exist.");
                }
                ls = spawn('node', ['app.js', 'env', args[0], 'serverType', 'master', 'serverId'  , 'master-server-1', 'debugServerId', serverId, 'debugPort', port]);
                break;
            default:
                abort("The start command  arguments is error.");
        }
        //reserve the child process pid
        fs.writeFile(process.cwd() + '/tmp', ls.pid);

        ls.stdout.on('data', function (data) {
            console.log('stdout: ' + data);
        });
        ls.stderr.on('data', function (data) {
            console.log('stderr: ' + data);
        });
        ls.on('exit', function (code) {
            console.log('child process exited with code ' + code);
        });
    }
    else {
        abort("Please go to your pomelo workspace to start the program");
    }
}

// list the servers of the program
function list() {
    if (ph.existsSync('./tmp')) {
        fs.readFile('./tmp', function (err, data) {
            if (err) throw err;
            process.kill(data, 'SIGINT');
            var client = require('socket.io-client');
            var socket = client.connect(LIST_COMMAND_ADDRESS);
            socket.on('connect', function () {
                socket.emit('message', Date.now());
                socket.on('info', function (data) {
                    console.log(data.info);
                    process.exit(1);
                });
            });
        });
    }
    else {
        abort("There is no starting program");
    }
}


// stop or kill the program
function terminal(signal) {
    if (ph.existsSync('./tmp')) {
        var ex = exec('ps -p ' + fs.readFileSync('./tmp'), function (error, stdout, stderr) {
            if (stdout.length <= 28) {
                fs.unlinkSync('./tmp');
                abort("The program is stopped.");
            }
            else {
                fs.readFile('./tmp', function (err, data) {
                    if (err) throw err;
                    console.log("closing the program......\nplease wait......");
                    if (signal === 'kill')
                        process.kill(data, 'SIGHUP');
                    else
                        process.kill(data, 'SIGTERM');
                    setTimeout(function () {
                        exec('kill -9 ' + data);
                    }, TIME_KILL_WAIT);
                });
            }
        });
    }
    else {
        abort("There is no starting program");
    }
}

/**
 * Check if the given directory `path` is empty.
 *
 * @param {String} path
 * @param {Function} fn
 */

function emptyDirectory(path, fn) {
    fs.readdir(path, function (err, files) {
        if (err && 'ENOENT' != err.code) throw err;
        fn(!files || !files.length);
    });
}

/**
 * echo str > path.
 *
 * @param {String} path
 * @param {String} str
 */

function write(path, str) {
    fs.writeFile(path, str);
    console.log('   \x1b[36mcreatefile\x1b[0m : ' + path);
}

/**
 * Prompt confirmation with the given `msg`.
 *
 * @param {String} msg
 * @param {Function} fn
 */

function confirm(msg, fn) {
    prompt(msg, function (val) {
        fn(/^ *y(es)?/i.test(val));
    });
}

/**
 * Prompt input with the given `msg` and callback `fn`.
 *
 * @param {String} msg
 * @param {Function} fn
 */

function prompt(msg, fn) {
    // prompt
    if (' ' == msg[msg.length - 1]) {
        process.stdout.write(msg);
    } else {
        console.log(msg);
    }

    // stdin
    process.stdin.setEncoding('ascii');
    process.stdin.once('data',function (data) {
        fn(data);
    }).resume();
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */

function abort(str) {
    console.error(str);
    process.exit(1);
}

/**
 *
 * @param {Number} argNum
 */

function legalArgNum(argNum) {
    if (args.length != argNum) {
        console.error("The command arguments number is error.");
        process.exit(1);
    }
}


/**
 * @param {String} origin
 * @param {String} target
 */
function copy(origin, target) {
    if (!ph.existsSync(origin)) {
        console.log(origin + 'is not exist......');
    }

    if (!ph.existsSync(target)) {
        mkdir(target, 0);
        console.log('   \x1b[36mmakedir\x1b[0m : ' + target);
    }

    fs.readdir(origin, function (err, datalist) {
        if (err) return;

        for (var i = 0; i < datalist.length; i++) {
            var oCurrent = origin + '/' + datalist[i];
            var tCurrent = target + '/' + datalist[i];

            if (fs.statSync(oCurrent).isFile()) {
                fs.writeFileSync(tCurrent, fs.readFileSync(oCurrent, ''), '');
                console.log('   \x1b[36mcreatefile\x1b[0m : ' + oCurrent);
            }

            else if (fs.statSync(oCurrent).isDirectory()) {
                copy(oCurrent, tCurrent);
            }
        }
    });
}

/**
 * mkdir
 *
 * @param {String} path
 * @param {Number} mode
 * @param {Function} cb
 */
function mkdir(url, mode, cb) {
    var path = require("path"), arr = url.split("/");
    mode = mode || 0755;
    cb = cb || function () {
    };
    if (arr[0] == ".") {
        arr.shift();
    }
    if (arr[0] == "..") {
        arr.splice(0, 2, arr[0] + "/" + arr[1]);
    }
    function inner(cur) {
        if (!path.existsSync(cur)) {
            fs.mkdirSync(cur, mode);
        }
        if (arr.length) {
            inner(cur + "/" + arr.shift());
        }
        else {
            cb();
        }
    }

    arr.length && inner(arr.shift());
    console.log('   \x1b[36mmakedir\x1b[0m : ' + url);
}

/**
 * Judge whether the serverId is legal.
 *
 * @param {String} mode
 * @param {String} serverId
 */
function legalServerId(mode, serverId) {
    var flag = '';
    var str = fs.readFileSync(__dirname + "/../template/config/servers.json");

    function readJson(mode, data) {
        var jsonObj = JSON.parse(data);
        var servers = [];

        function pushServerId(arr) {
            for (var i = 0; i < arr.length; i++) {
                servers.push(arr[i].id);
            }
        }

        if (mode === 'development') {
            var jo = jsonObj.development;
            pushServerId(jo.connector);
            pushServerId(jo.area);
            pushServerId(jo.status);
            pushServerId(jo.channel);
        }
        else {
            var jo = jsonObj.production;
            pushServerId(jo.connector);
            pushServerId(jo.area);
            pushServerId(jo.status);
        }
        for (var j = 0; j < servers.length; j++) {
            if (servers[j] === serverId) {
                return true;
            }
        }
        return false;
    }

    return readJson(mode, str);
}
